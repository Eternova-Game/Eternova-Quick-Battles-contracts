var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { Signer as AbstractSigner } from '@ethersproject/abstract-signer';
import { BigNumber } from '@ethersproject/bignumber';
import { arrayify, isBytesLike } from '@ethersproject/bytes';
import * as rlp from '@ethersproject/rlp';
import { JsonRpcProvider, Provider as AbstractProvider, Web3Provider, } from '@ethersproject/providers';
import * as cbor from 'cborg';
import { ethers as ethers6 } from 'ethers6';
import { Kind as CipherKind, X25519DeoxysII, fetchRuntimePublicKeyByChainId, lazy as lazyCipher, } from './cipher.js';
import { CallError, OASIS_CALL_DATA_PUBLIC_KEY } from './index.js';
import { SignedCallDataPack } from './signed_calls.js';
const SAPPHIRE_PROP = 'sapphire';
/** If a gas limit is not provided, the runtime will produce a very confusing error message, so we set a default limit. This one is very high, but solves the problem. This should be lowered once error messages are better or gas estimation is enabled. */
const DEFAULT_GAS = 10000000;
export function wrap(upstream, customCipher) {
    // Already wrapped, so don't wrap it again.
    if (typeof upstream !== 'string' &&
        Reflect.get(upstream, SAPPHIRE_PROP) !== undefined) {
        return upstream;
    }
    if (typeof upstream === 'string') {
        const provider = new JsonRpcProvider(upstream);
        const cipher = customCipher !== null && customCipher !== void 0 ? customCipher : getCipher(provider);
        const request = hookExternalProvider(provider, cipher);
        const sendAsync = callbackify(request);
        return makeProxy(provider, cipher, {
            send: sendAsync,
            sendAsync,
            request,
        });
    }
    const cipher = customCipher !== null && customCipher !== void 0 ? customCipher : getCipher(upstream);
    if (isEthers6Signer(upstream)) {
        let signer;
        if (upstream.provider) {
            try {
                signer = upstream.connect(wrapEthers6Provider(upstream.provider, cipher, upstream));
            }
            catch (e) {
                if (e.code !== 'UNSUPPORTED_OPERATION')
                    throw e;
                signer = upstream;
            }
        }
        else {
            signer = upstream;
        }
        const hooks = {
            sendTransaction: hookEthers6Send(signer.sendTransaction.bind(signer), cipher),
            signTransaction: hookEthers6Send(signer.signTransaction.bind(signer), cipher),
            call: hookEthers6Call(signer, 'call', cipher),
            estimateGas: () => __awaiter(this, void 0, void 0, function* () { return BigInt(DEFAULT_GAS); }),
            connect(provider) {
                return wrap(signer.connect(provider), cipher);
            },
        };
        return makeProxy(signer, cipher, hooks);
    }
    if (isEthers5Signer(upstream)) {
        let signer;
        if (upstream.provider) {
            try {
                signer = upstream.connect(wrapEthers5Provider(upstream.provider, cipher, upstream));
            }
            catch (e) {
                if (e.code !== 'UNSUPPORTED_OPERATION')
                    throw e;
                signer = upstream;
            }
        }
        else {
            signer = upstream;
        }
        const hooks = {
            sendTransaction: hookEthers5Send(signer.sendTransaction.bind(signer), cipher),
            signTransaction: hookEthers5Send(signer.signTransaction.bind(signer), cipher),
            call: hookEthers5Call(signer, 'call', cipher),
            // TODO(#39): replace with original once resolved
            estimateGas: () => __awaiter(this, void 0, void 0, function* () { return BigNumber.from(DEFAULT_GAS); }),
            // estimateGas: hookEthersCall(
            //   signer.estimateGas.bind(signer),
            //   cipher,
            //   signer,
            // ),
            connect(provider) {
                return wrap(signer.connect(provider), cipher);
            },
        };
        return makeProxy(signer, cipher, hooks);
    }
    if (isEthers5Provider(upstream)) {
        return wrapEthers5Provider(upstream, cipher);
    }
    if (isEthers6Provider(upstream)) {
        return wrapEthers6Provider(upstream, cipher);
    }
    if ('request' in upstream || 'send' in upstream || 'sendAsync' in upstream) {
        const signer = makeWeb3Provider(upstream).getSigner();
        const request = hookExternalSigner(signer, cipher);
        const sendAsync = callbackify(request);
        let send = sendAsync;
        if ('send' in upstream && isEthersSend(upstream.send)) {
            // If the provided `send` is an `JsonRpcProvider.send`, we need to provide that instead of the usual `AsyncSend`
            send = ((method, params) => request({ method, params }));
        }
        return makeProxy(upstream, cipher, {
            request,
            send,
            sendAsync,
        });
    }
    throw new TypeError('Unable to wrap unsupported upstream signer.');
}
function isEthersSend(send) {
    if (!send)
        return false;
    // If the function is async, it's likely ethers send.
    try {
        const res = send(); // either rejects or calls back with an error
        if (res instanceof Promise) {
            res.catch(() => void {}); // handle the rejection before the next tick
            return true;
        }
    }
    catch (_a) {
        // This is prophyalictic. Neither kind of `send` should synchronously throw.
    }
    return false;
}
function getCipher(provider) {
    return lazyCipher(() => __awaiter(this, void 0, void 0, function* () {
        const rtPubKey = yield fetchRuntimePublicKey(provider);
        return X25519DeoxysII.ephemeral(rtPubKey);
    }));
}
function makeProxy(upstream, cipher, hooks) {
    return new Proxy(upstream, {
        get(upstream, prop) {
            if (prop === SAPPHIRE_PROP)
                return { cipher };
            if (prop in hooks)
                return Reflect.get(hooks, prop);
            const value = Reflect.get(upstream, prop);
            return typeof value === 'function' ? value.bind(upstream) : value;
        },
    });
}
function wrapEthers5Provider(provider, cipher, signer) {
    // Already wrapped, so don't wrap it again.
    if (Reflect.get(provider, SAPPHIRE_PROP) !== undefined) {
        return provider;
    }
    // If a signer is provided it's because this method was invoked by wrapping a signer,
    // so the `call` and `estimateGas` methods are already hooked.
    const hooks = signer
        ? {
            sendTransaction: ((raw) => __awaiter(this, void 0, void 0, function* () {
                const repacked = yield repackRawTx(yield raw, cipher, signer);
                return provider.sendTransaction(repacked);
            })),
        }
        : {
            // Calls can be unsigned, but must be enveloped.
            call: hookEthers5Call(provider, 'call', cipher),
            estimateGas: hookEthers5Call(provider, 'estimateGas', cipher),
        };
    return makeProxy(provider, cipher, hooks);
}
function wrapEthers6Provider(provider, cipher, signer) {
    // Already wrapped, so don't wrap it again.
    if (Reflect.get(provider, SAPPHIRE_PROP) !== undefined) {
        return provider;
    }
    const hooks = signer
        ? {}
        : {
            // Calls can be unsigned, but must be enveloped.
            call: hookEthers6Call(provider, 'call', cipher),
            estimateGas: hookEthers6Call(provider, 'estimateGas', cipher),
        };
    return makeProxy(provider, cipher, hooks);
}
function isEthers5Provider(upstream) {
    return AbstractProvider.isProvider(upstream);
}
function isEthers5Signer(upstream) {
    return AbstractSigner.isSigner(upstream) && '_signTypedData' in upstream;
}
function isEthers6Signer(upstream) {
    return upstream instanceof ethers6.AbstractSigner;
}
function isEthers6Provider(upstream) {
    return upstream instanceof ethers6.AbstractProvider;
}
function hookEthers5Call(runner, method, cipher) {
    const sendUnsignedCall = (provider, callP, blockTag) => __awaiter(this, void 0, void 0, function* () {
        return provider[method](Object.assign(Object.assign({}, callP), { data: cipher.encryptEncode(yield callP.data) }), blockTag);
    });
    return (callP, blockTag) => __awaiter(this, void 0, void 0, function* () {
        let res;
        if (isEthers5Signer(runner)) {
            const signer = runner;
            if (yield callNeedsSigning(callP)) {
                const dataPack = yield SignedCallDataPack.make((yield undefer(callP)) /* callNeedsSigning ensures type */, signer);
                res = yield signer[method](Object.assign(Object.assign({}, callP), { data: dataPack.encryptEncode(cipher) }), blockTag);
            }
            else {
                if (!signer.provider)
                    throw new Error('unable to sign call');
                res = yield sendUnsignedCall(signer.provider, callP, blockTag);
            }
        }
        else {
            res = yield sendUnsignedCall(runner, callP, blockTag);
        }
        if (typeof res === 'string')
            return cipher.decryptEncoded(res);
        return res;
    });
}
function hookEthers6Call(runner, method, cipher) {
    const sendUnsignedCall = (runner, call) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        return runner[method](Object.assign(Object.assign({}, call), { data: yield cipher.encryptEncode((_a = call.data) !== null && _a !== void 0 ? _a : new Uint8Array()) }));
    });
    return (call) => __awaiter(this, void 0, void 0, function* () {
        let res;
        if (isEthers6Signer(runner)) {
            const signer = runner;
            if (!signer.provider)
                throw new Error('signer not connected to a provider');
            const provider = signer.provider;
            if (yield callNeedsSigning(call)) {
                const dataPack = yield SignedCallDataPack.make((yield undefer(call)) /* callNeedsSigning ensures type */, signer);
                res = yield provider[method](Object.assign(Object.assign({}, call), { data: yield dataPack.encryptEncode(cipher) }));
            }
            else {
                res = yield sendUnsignedCall(provider, call);
            }
        }
        else {
            res = yield sendUnsignedCall(runner, call);
        }
        if (typeof res === 'string')
            return cipher.decryptEncoded(res);
        return res;
    });
}
function hookEthers5Send(send, cipher) {
    return (tx, ...rest) => __awaiter(this, void 0, void 0, function* () {
        const data = yield tx.data;
        tx.data = cipher.encryptEncode(data);
        if (!tx.gasLimit)
            tx.gasLimit = DEFAULT_GAS;
        return send(tx, ...rest);
    });
}
function hookEthers6Send(send, cipher) {
    return (tx, ...rest) => __awaiter(this, void 0, void 0, function* () {
        if (tx.data)
            tx.data = yield cipher.encryptEncode(tx.data);
        if (!tx.gasLimit)
            tx.gasLimit = DEFAULT_GAS;
        return send(tx, ...rest);
    });
}
function callNeedsSigning(callP) {
    return __awaiter(this, void 0, void 0, function* () {
        const [from, to] = yield Promise.all([callP.from, callP.to]);
        return (!!to && !!from && typeof from === 'string' && !/^(0x)?0{40}$/.test(from));
    });
}
function undefer(obj) {
    return __awaiter(this, void 0, void 0, function* () {
        return Object.fromEntries(yield Promise.all(Object.entries(obj).map(([k, v]) => __awaiter(this, void 0, void 0, function* () { return [k, yield v]; }))));
    });
}
function hookExternalSigner(signer, cipher) {
    return (args) => __awaiter(this, void 0, void 0, function* () {
        if (args.method === 'eth_estimateGas')
            return BigNumber.from(DEFAULT_GAS).toHexString(); // TODO(#39)
        const { method, params } = yield prepareRequest(args, signer, cipher);
        const res = yield signer.provider.send(method, params !== null && params !== void 0 ? params : []);
        if (method === 'eth_call')
            return cipher.decryptEncoded(res);
        return res;
    });
}
function hookExternalProvider(provider, cipher) {
    return ({ method, params }) => __awaiter(this, void 0, void 0, function* () {
        if (method === 'eth_estimateGas')
            return BigNumber.from(DEFAULT_GAS).toHexString(); // TODO(#39)
        if (method === 'eth_call' && params) {
            params[0].data = yield cipher.encryptEncode(params[0].data);
            if (!params[0].gasLimit)
                params[0].gasLimit = DEFAULT_GAS;
            return provider.send(method, params);
        }
        return provider.send(method, params !== null && params !== void 0 ? params : []);
    });
}
function callbackify(request) {
    return (args, cb) => {
        request(args)
            .then((res) => cb(null, { jsonrpc: '2.0', id: args.id, result: res }))
            .catch((err) => cb(err));
    };
}
function prepareRequest({ method, params }, signer, cipher) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!Array.isArray(params))
            return { method, params };
        if (method === 'eth_sendRawTransaction') {
            return {
                method,
                params: [yield repackRawTx(params[0], cipher, signer)],
            };
        }
        if ((method === 'eth_call' || method === 'eth_estimateGas') &&
            (yield callNeedsSigning(params[0]))) {
            const dataPack = yield SignedCallDataPack.make(params[0], signer);
            const signedCall = Object.assign(Object.assign({}, params[0]), { data: yield dataPack.encryptEncode(cipher) });
            return {
                method,
                params: [signedCall, ...params.slice(1)],
            };
        }
        if (/^eth_((send|sign)Transaction|call|estimateGas)$/.test(method)) {
            params[0].data = yield cipher.encryptEncode(params[0].data);
            if (!params[0].gasLimit)
                params[0].gasLimit = DEFAULT_GAS;
            return { method, params };
        }
        return { method, params };
    });
}
const REPACK_ERROR = 'Un-enveloped data was passed to sendRawTransaction, which is likely incorrect. Is the dapp using the Sapphire compat lib correctly?';
/** Repacks and signs a sendRawTransaction if needed and possible. */
function repackRawTx(raw, cipher, signer) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function* () {
        const DATA_FIELD = 5;
        const txFields = rlp.decode(raw);
        const data = arrayify(txFields[DATA_FIELD], { allowMissingPrefix: true });
        try {
            const _d = cbor.decode(data), { format, body } = _d, extra = __rest(_d, ["format", "body"]);
            if (envelopeFormatOk(format, body, extra))
                return raw;
            throw new EnvelopeError('Bogus enveloped data found in sendRawTransaction.');
        }
        catch (e) {
            if (e instanceof EnvelopeError)
                throw e;
            if (((_b = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.process) === null || _a === void 0 ? void 0 : _a.env) === null || _b === void 0 ? void 0 : _b.NODE_ENV) !== 'test') {
                console.trace(REPACK_ERROR);
            }
        }
        const tx = ethers6.Transaction.from(raw);
        const q = (v) => {
            if (!v)
                return undefined;
            return ethers6.toQuantity(v);
        };
        const parsed = {
            to: tx.to,
            from: tx.from,
            data: tx.data,
            nonce: tx.nonce,
            gasLimit: q(tx.gasLimit),
            gasPrice: (_c = q(tx.gasPrice)) !== null && _c !== void 0 ? _c : undefined,
            value: q(tx.value),
            chainId: Number(tx.chainId),
        };
        if (!signer)
            throw new CallError(REPACK_ERROR, null);
        if (!parsed.gasLimit)
            parsed.gasLimit = q(BigInt(DEFAULT_GAS)); // TODO(39)
        try {
            return signer.signTransaction(Object.assign(Object.assign({}, parsed), { data: yield cipher.encryptEncode(data) }));
        }
        catch (e) {
            throw new CallError(REPACK_ERROR, e);
        }
    });
}
function envelopeFormatOk(format, body, extra) {
    if (Object.keys(extra).length > 0)
        return false;
    if (!body)
        return false;
    if (format && format !== CipherKind.Plain) {
        if (isBytesLike(body) || !isBytesLike(body.data))
            return false;
    }
    return true;
}
class EnvelopeError extends Error {
}
function defer() {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject) => {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
/**
 * Picks the most user-trusted runtime calldata public key source based on what
 * connections are available.
 * Note: MetaMask does not support Web3 methods it doesn't know about, so we have to
 * fall back to manually querying the default gateway.
 */
export function fetchRuntimePublicKey(upstream) {
    return __awaiter(this, void 0, void 0, function* () {
        const isEthersSigner = isEthers5Signer(upstream) || isEthers6Signer(upstream);
        const provider = isEthersSigner ? upstream['provider'] : upstream;
        if (provider && 'send' in provider) {
            // first opportunistically try `send` from the provider
            try {
                const source = provider;
                // For Truffle, turn a callback into an synchronous call
                const deferred = defer();
                const truffle_callback = function (err, ok) {
                    if (ok) {
                        deferred.resolve(ok.result);
                    }
                    deferred.reject(err);
                    return;
                };
                let resp;
                if (!isEthersSigner &&
                    !isEthers5Provider(provider) &&
                    !isEthers6Provider(provider)) {
                    // Truffle HDWallet-Provider and EIP-1193 accept {method:,params:} dict
                    resp = yield source.send({ method: OASIS_CALL_DATA_PUBLIC_KEY, params: [] }, truffle_callback);
                    if (resp === undefined) {
                        // Truffle HDWallet-provider uses a callback instead of returning a promise
                        resp = yield deferred.promise;
                        if (resp === undefined) {
                            throw Error('Got unexpected `undefined` from source.send callback!');
                        }
                    }
                    else {
                        // Otherwise, EIP-1193 compatible provider will have returned `result` key from promise
                    }
                }
                else {
                    // Whereas Ethers accepts (method,params)
                    resp = yield source.send(OASIS_CALL_DATA_PUBLIC_KEY, []);
                }
                if ('key' in resp) {
                    const key = resp.key;
                    return arrayify(key);
                }
            }
            catch (ex) {
                // don't do anything, move on to try chainId
            }
        }
        if (isEthers5Provider(upstream) || isEthers6Provider(upstream)) {
            const chainId = Number((yield upstream.getNetwork()).chainId);
            return fetchRuntimePublicKeyByChainId(chainId);
        }
        if (isEthersSigner) {
            const chainId = Number((yield upstream.provider.getNetwork()).chainId);
            return fetchRuntimePublicKeyByChainId(chainId);
        }
        const chainId = (yield makeWeb3Provider(upstream).getNetwork()).chainId;
        return fetchRuntimePublicKeyByChainId(chainId);
    });
}
function makeWeb3Provider(upstream) {
    let provider;
    if ('send' in upstream && isEthersSend(upstream.send)) {
        provider = {
            request: ({ method, params }) => upstream.send(method, params !== null && params !== void 0 ? params : []),
        };
    }
    else {
        provider = upstream;
    }
    return new Web3Provider(provider);
}
//# sourceMappingURL=compat.js.map