import { BlockTag, Provider } from '@ethersproject/abstract-provider';
import { Signer as Ethers5Signer, TypedDataDomain, TypedDataField, TypedDataSigner } from '@ethersproject/abstract-signer';
import { BigNumber, BigNumberish } from '@ethersproject/bignumber';
import { BytesLike } from '@ethersproject/bytes';
import { ethers } from 'ethers6';
import type { CamelCasedProperties, RequireExactlyOne } from 'type-fest';
import { Cipher } from './cipher.js';
export type Signer = CallSigner;
export type CallSigner = Ethers5CallSigner | ethers.Signer;
export type Ethers5CallSigner = Pick<Ethers5Signer, 'getTransactionCount' | 'getChainId' | 'getAddress'> & TypedDataSigner & {
    provider?: Pick<Provider, 'getBlock' | 'getNetwork'>;
};
export declare function signedCallEIP712Params(chainId: number): {
    domain: TypedDataDomain;
    types: Record<string, TypedDataField[]>;
};
/**
 * Parameters that define a signed call that shall be
 * CBOR-encoded and sent as the call's `data` field.
 */
export declare class SignedCallDataPack {
    #private;
    readonly leash: Leash;
    /** A signature over the call and leash as generated by `signCall`. */
    readonly signature: Uint8Array;
    /**
     * An oasis-sdk `Call` without the optional fields.
     *
     * After encryption, `body` would be encrypted and this field would contain a
     * `format` field. The runtime would decode the data as a `types::transaction::Call`.
     **/
    readonly data?: Uint8Array | undefined;
    static make<C extends EthCall>(call: C, signer: CallSigner, overrides?: PrepareSignedCallOverrides): Promise<SignedCallDataPack>;
    private constructor();
    encode(): string;
    /** Encodes the data pack after encrypting the signed call data. */
    encryptEncode(cipher: Cipher): Promise<string>;
}
export declare function makeSignableCall(call: EthCall, leash: Leash): SignableEthCall;
export type PrepareSignedCallOverrides = Partial<{
    leash: LeashOverrides;
    chainId: number;
}>;
export type LeashOverrides = Partial<{
    nonce: number;
    blockRange: number;
} & RequireExactlyOne<{
    block: BlockId;
    blockTag: BlockTag;
}>>;
export type EthCall = {
    /** 0x-prefixed hex-encoded address. */
    from: string;
    /** Optional 0x-prefixed hex-encoded address. */
    to?: string;
    value?: BigNumberish;
    gasPrice?: BigNumberish;
    data?: BytesLike;
} & Partial<RequireExactlyOne<{
    gas: number | string;
    gasLimit: BigNumberish;
}>>;
/**
 * The structure passed to eth_signTypedData_v4.
 *
 * `uint256`, `address`, and `bytes` are required to be hex-stringified.
 */
export type SignableEthCall = {
    from: string;
    to: string;
    gasLimit?: number;
    gasPrice?: BigNumber;
    value?: BigNumber;
    data?: string;
    leash: CamelCasedProperties<Leash>;
};
export type Leash = {
    /** The largest sender account nonce whence the call will be valid. */
    nonce: number;
    /** The block number whence the call will be valid. */
    block_number: number;
    /** The expected block hash to be found at `block_number`. */
    block_hash: Uint8Array;
    /** The number of blocks past the block at `block_number` whence the call will be valid. */
    block_range: number;
};
export type BlockId = {
    hash: string;
    number: number;
};
//# sourceMappingURL=signed_calls.d.ts.map