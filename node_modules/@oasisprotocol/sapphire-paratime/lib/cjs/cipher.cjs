"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchRuntimePublicKeyByChainId = exports.lazy = exports.Mock = exports.X25519DeoxysII = exports.Plain = exports.Cipher = exports.Kind = void 0;
const bytes_1 = require("@ethersproject/bytes");
const cbor = __importStar(require("cborg"));
const deoxysii_1 = __importDefault(require("@oasisprotocol/deoxysii"));
const js_sha512_1 = require("js-sha512");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const index_js_1 = require("./index.cjs");
var Kind;
(function (Kind) {
    Kind[Kind["Plain"] = 0] = "Plain";
    Kind[Kind["X25519DeoxysII"] = 1] = "X25519DeoxysII";
    Kind[Kind["Mock"] = Number.MAX_SAFE_INTEGER] = "Mock";
})(Kind = exports.Kind || (exports.Kind = {}));
class Cipher {
    /** Encrypts the plaintext and encodes it for sending. */
    encryptEncode(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const envelope = yield this.encryptEnvelope(plaintext);
            return envelope ? (0, bytes_1.hexlify)(cbor.encode(envelope)) : '';
        });
    }
    /** Encrypts the plaintext and formats it into an envelope. */
    encryptEnvelope(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (plaintext === undefined)
                return;
            if (!(0, bytes_1.isBytesLike)(plaintext)) {
                throw new Error('Attempted to sign tx having non-byteslike data.');
            }
            if (plaintext.length === 0)
                return; // Txs without data are just balance transfers, and all data in those is public.
            const { data, nonce } = yield this.encryptCallData((0, bytes_1.arrayify)(plaintext));
            const [format, pk] = yield Promise.all([this.kind, this.publicKey]);
            const body = pk.length && nonce.length ? { pk, nonce, data } : data;
            if (format === Kind.Plain)
                return { body };
            return { format, body };
        });
    }
    encryptCallData(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const body = cbor.encode({ body: plaintext });
            const { ciphertext: data, nonce } = yield this.encrypt(body);
            return { data, nonce };
        });
    }
    /**
     *  Decrypts the data contained within call
     *
     *  This is useful for creating tools, and also decoding
     *  previously-sent transactions that have used the same
     *  encryption key.
     */
    decryptCallData(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return cbor.decode(yield this.decrypt(nonce, ciphertext)).body;
        });
    }
    /**
     * @hidden Encrypts a CallResult in the same way as would be returned by the runtime.
     * This method is not part of the SemVer interface and may be subject to change.
     */
    encryptCallResult(result, reportUnknown = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (result.fail)
                return cbor.encode(result);
            const encodedResult = cbor.encode(result);
            const { ciphertext, nonce } = yield this.encrypt(encodedResult);
            const prop = reportUnknown ? 'unknown' : 'ok';
            return cbor.encode({ [prop]: { nonce, data: ciphertext } });
        });
    }
    /** Decrypts the data contained within a hex-encoded serialized envelope. */
    decryptEncoded(callResult) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, bytes_1.hexlify)(yield this.decryptCallResult(cbor.decode((0, bytes_1.arrayify)(callResult))));
        });
    }
    /** Decrypts the data contained within a result envelope. */
    decryptCallResult(res) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            function formatFailure(fail) {
                if (fail.message)
                    return fail.message;
                return `Call failed in module '${fail.module}' with code '${fail.code}'`;
            }
            if (res.fail)
                throw new index_js_1.CallError(formatFailure(res.fail), res.fail);
            if (res.ok && (typeof res.ok === 'string' || res.ok instanceof Uint8Array))
                return (0, bytes_1.arrayify)(res.ok);
            const { nonce, data } = (_a = res.ok) !== null && _a !== void 0 ? _a : res.unknown;
            const inner = cbor.decode(yield this.decrypt(nonce, data));
            if (inner.ok)
                return (0, bytes_1.arrayify)(inner.ok);
            if (inner.fail)
                throw new index_js_1.CallError(formatFailure(inner.fail), inner.fail);
            throw new index_js_1.CallError(`Unexpected inner call result: ${JSON.stringify(inner)}`, inner);
        });
    }
}
exports.Cipher = Cipher;
/**
 * A {@link Cipher} that does not encrypt data.
 *
 * This cipher is useful for debugging and sending messages that
 * you would prefer everyone to be able to see (e.g., for auditing purposes).
 */
class Plain extends Cipher {
    constructor() {
        super(...arguments);
        this.kind = Kind.Plain;
        this.publicKey = new Uint8Array();
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { ciphertext: plaintext, nonce: new Uint8Array() };
        });
    }
    decrypt(_nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return ciphertext;
        });
    }
    encryptCallData(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { data: plaintext, nonce: new Uint8Array() };
        });
    }
}
exports.Plain = Plain;
/**
 * A {@link Cipher} that derives a shared secret using X25519 and then uses DeoxysII for encrypting using that secret.
 *
 * This is the default cipher.
 */
class X25519DeoxysII extends Cipher {
    /** Creates a new cipher using an ephemeral keypair stored in memory. */
    static ephemeral(peerPublicKey) {
        const keypair = tweetnacl_1.default.box.keyPair();
        return new X25519DeoxysII(keypair, (0, bytes_1.arrayify)(peerPublicKey, { allowMissingPrefix: true }));
    }
    static fromSecretKey(secretKey, peerPublicKey) {
        const keypair = tweetnacl_1.default.box.keyPair.fromSecretKey((0, bytes_1.arrayify)(secretKey));
        return new X25519DeoxysII(keypair, (0, bytes_1.arrayify)(peerPublicKey));
    }
    constructor(keypair, peerPublicKey) {
        super();
        this.kind = Kind.X25519DeoxysII;
        this.publicKey = keypair.publicKey;
        // Derive a shared secret using X25519 (followed by hashing to remove ECDH bias).
        const keyBytes = js_sha512_1.sha512_256.hmac
            .create('MRAE_Box_Deoxys-II-256-128')
            .update(tweetnacl_1.default.scalarMult(keypair.secretKey, peerPublicKey))
            .arrayBuffer();
        this.key = new Uint8Array(keyBytes);
        this.cipher = new deoxysii_1.default.AEAD(new Uint8Array(this.key)); // deoxysii owns the input
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            const nonce = tweetnacl_1.default.randomBytes(deoxysii_1.default.NonceSize);
            const ciphertext = this.cipher.encrypt(nonce, plaintext);
            return { nonce, ciphertext };
        });
    }
    decrypt(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.cipher.decrypt(nonce, ciphertext);
        });
    }
}
exports.X25519DeoxysII = X25519DeoxysII;
/** A cipher that pretends to be an encrypting cipher. Used for tests. */
class Mock extends Cipher {
    constructor() {
        super(...arguments);
        this.kind = Kind.Mock;
        this.publicKey = new Uint8Array([1, 2, 3]);
    }
    encrypt(plaintext) {
        return __awaiter(this, void 0, void 0, function* () {
            return { nonce: Mock.NONCE, ciphertext: plaintext };
        });
    }
    decrypt(nonce, ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((0, bytes_1.hexlify)(nonce) !== (0, bytes_1.hexlify)(Mock.NONCE))
                throw new Error('incorrect nonce');
            return ciphertext;
        });
    }
}
exports.Mock = Mock;
Mock.NONCE = new Uint8Array([10, 20, 30, 40]);
/**
 * A Cipher that constructs itself only when needed.
 * Useful for deferring async construction (e.g., fetching public keys) until in an async context.
 *
 * @param generator A function that yields the cipher implementation. This function must be multiply callable and without observable side effects (c.f. Rust's `impl Fn()`).
 */
function lazy(generator) {
    // Note: in cases when `generate` is run concurrently, the first fulfillment will be used.
    return new Proxy({}, {
        get(target, prop) {
            // Props (Promiseable)
            if (prop === 'kind' || prop === 'publicKey') {
                if (!target.inner)
                    target.inner = Promise.resolve(generator());
                return target.inner.then((c) => Reflect.get(c, prop));
            }
            // Funcs (async)
            return (...args) => __awaiter(this, void 0, void 0, function* () {
                if (!target.inner)
                    target.inner = Promise.resolve(generator());
                return target.inner.then((c) => Reflect.get(c, prop).apply(c, args));
            });
        },
    });
}
exports.lazy = lazy;
function fetchRuntimePublicKeyByChainId(chainId, opts) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { defaultGateway: gatewayUrl } = index_js_1.NETWORKS[chainId];
        if (!gatewayUrl)
            throw new Error(`Unable to fetch runtime public key for network with unknown ID: ${chainId}.`);
        const fetchImpl = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.fetch) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.fetch;
        const res = yield (fetchImpl
            ? fetchRuntimePublicKeyBrowser(gatewayUrl, fetchImpl)
            : fetchRuntimePublicKeyNode(gatewayUrl));
        return (0, bytes_1.arrayify)(res.result.key);
    });
}
exports.fetchRuntimePublicKeyByChainId = fetchRuntimePublicKeyByChainId;
function fetchRuntimePublicKeyNode(gwUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        // Import http or https, depending on the URI scheme.
        const https = yield (_a = gwUrl.split(':')[0], Promise.resolve().then(() => __importStar(require(_a))));
        const body = makeCallDataPublicKeyBody();
        return new Promise((resolve, reject) => {
            const opts = {
                method: 'POST',
                headers: {
                    'content-type': 'application/json',
                    'content-length': body.length,
                },
            };
            const req = https.request(gwUrl, opts, (res) => {
                const chunks = [];
                res.on('error', (err) => reject(err));
                res.on('data', (chunk) => chunks.push(chunk));
                res.on('end', () => {
                    resolve(JSON.parse(Buffer.concat(chunks).toString()));
                });
            });
            req.on('error', (err) => reject(err));
            req.write(body);
            req.end();
        });
    });
}
function fetchRuntimePublicKeyBrowser(gwUrl, fetchImpl) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield fetchImpl(gwUrl, {
            method: 'POST',
            headers: {
                'content-type': 'application/json',
            },
            body: makeCallDataPublicKeyBody(),
        });
        if (!res.ok) {
            throw new index_js_1.CallError('Failed to fetch runtime public key.', res);
        }
        return yield res.json();
    });
}
function makeCallDataPublicKeyBody() {
    return JSON.stringify({
        jsonrpc: '2.0',
        id: Math.floor(Math.random() * 1e9),
        method: index_js_1.OASIS_CALL_DATA_PUBLIC_KEY,
        params: [],
    });
}
//# sourceMappingURL=cipher.js.map